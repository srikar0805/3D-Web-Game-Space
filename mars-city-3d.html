<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Mars City 3D - Open World Colony Builder</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  html,body{height:100%;overflow:hidden;background:#000;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;color:#fff}
  
  #hud{position:fixed;top:16px;left:16px;right:16px;display:flex;justify-content:space-between;z-index:10;pointer-events:none}
  .hud-panel{background:linear-gradient(135deg,rgba(15,15,25,.95),rgba(25,15,20,.95));border:2px solid rgba(255,100,50,.6);border-radius:12px;padding:12px 16px;backdrop-filter:blur(10px);pointer-events:auto}
  .hud-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  .resource{display:flex;align-items:center;gap:8px;font-size:15px;font-weight:700}
  .resource-icon{font-size:20px}
  .resource-bar{width:80px;height:6px;background:rgba(255,255,255,.2);border-radius:3px;overflow:hidden}
  .resource-fill{height:100%;background:linear-gradient(90deg,#4caf50,#8bc34a);transition:width .3s}
  
  #buildPanel{position:fixed;right:16px;top:50%;transform:translateY(-50%);background:linear-gradient(135deg,rgba(15,15,25,.95),rgba(25,15,20,.95));border:2px solid rgba(255,100,50,.6);border-radius:12px;padding:16px;max-width:220px;z-index:10;backdrop-filter:blur(10px)}
  #buildPanel h3{margin-bottom:12px;color:#ff6432;font-size:18px;text-align:center}
  .build-category{margin-bottom:16px}
  .category-title{font-size:13px;color:#ffab91;margin-bottom:8px;font-weight:600;text-transform:uppercase}
  .build-btn{width:100%;cursor:pointer;background:linear-gradient(135deg,#37474f,#263238);border:2px solid #546e7a;color:#fff;padding:10px;margin-bottom:6px;border-radius:8px;font-weight:700;font-size:13px;transition:all .2s;text-align:left;display:flex;justify-content:space-between;align-items:center}
  .build-btn:hover{transform:translateX(-4px);border-color:#ff6432;box-shadow:0 0 15px rgba(255,100,50,.4)}
  .build-btn.selected{background:linear-gradient(135deg,#ff6432,#d84315);border-color:#ffab91;box-shadow:0 0 20px rgba(255,100,50,.6)}
  .build-cost{font-size:11px;opacity:.8}
  
  #info{position:fixed;bottom:16px;left:16px;background:linear-gradient(135deg,rgba(15,15,25,.95),rgba(25,15,20,.95));border:2px solid rgba(255,100,50,.6);border-radius:12px;padding:12px 16px;max-width:400px;z-index:10;backdrop-filter:blur(10px)}
  #info h4{color:#ff6432;margin-bottom:6px}
  #info p{font-size:13px;line-height:1.5;color:#ccc}
  
  #controls{position:fixed;bottom:16px;right:16px;background:linear-gradient(135deg,rgba(15,15,25,.95),rgba(25,15,20,.95));border:2px solid rgba(255,100,50,.6);border-radius:12px;padding:10px 14px;font-size:12px;z-index:10;backdrop-filter:blur(10px);max-width:280px}
  #controls div{margin:4px 0}
  
  #toast{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.95);border:3px solid #ff6432;padding:24px 40px;border-radius:16px;font-size:26px;font-weight:800;opacity:0;transition:opacity .3s;pointer-events:none;z-index:30;text-align:center}
  
  #menu{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:linear-gradient(135deg,rgba(10,5,15,.98),rgba(20,10,10,.98));z-index:40}
  #menu h1{font-size:48px;margin-bottom:16px;color:#ff6432;text-shadow:0 0 20px rgba(255,100,50,.8)}
  #menu p{font-size:18px;margin-bottom:32px;color:#ccc;max-width:600px;text-align:center;line-height:1.6}
  #menu button{cursor:pointer;background:linear-gradient(135deg,#ff6432,#d84315);border:3px solid #ffab91;color:#fff;padding:18px 48px;border-radius:16px;font-weight:900;font-size:22px;box-shadow:0 0 40px rgba(255,100,50,.6);transition:all .3s}
  #menu button:hover{transform:scale(1.1);box-shadow:0 0 60px rgba(255,100,50,.9)}
  
  canvas{display:block}
</style>
</head>
<body>
  <div id="hud">
    <div class="hud-panel">
      <div class="hud-grid">
        <div class="resource">
          <span class="resource-icon">üë•</span>
          <div>
            <div style="font-size:11px;opacity:.7">Population</div>
            <div id="pop">0</div>
          </div>
        </div>
        <div class="resource">
          <span class="resource-icon">üí∞</span>
          <div>
            <div style="font-size:11px;opacity:.7">Credits</div>
            <div id="credits">500</div>
          </div>
        </div>
        <div class="resource">
          <span class="resource-icon">‚ö°</span>
          <div>
            <div style="font-size:11px;opacity:.7">Energy</div>
            <div id="energy">0/0</div>
          </div>
        </div>
        <div class="resource">
          <span class="resource-icon">üåæ</span>
          <div>
            <div style="font-size:11px;opacity:.7">Food</div>
            <div id="food">50</div>
          </div>
        </div>
        <div class="resource">
          <span class="resource-icon">üíß</span>
          <div>
            <div style="font-size:11px;opacity:.7">Water</div>
            <div id="water">40</div>
          </div>
        </div>
        <div class="resource">
          <span class="resource-icon">üî¨</span>
          <div>
            <div style="font-size:11px;opacity:.7">Research</div>
            <div id="research">0</div>
          </div>
        </div>
      </div>
    </div>
    <div class="hud-panel">
      <div style="font-size:14px">Sol <span id="day" style="font-weight:800;color:#ff6432">1</span></div>
      <div style="font-size:11px;opacity:.7;margin-top:4px">FPS: <span id="fps">60</span></div>
    </div>
  </div>
  
  <div id="buildPanel">
    <h3>üèóÔ∏è Build Menu</h3>
    <div class="build-category">
      <div class="category-title">Infrastructure</div>
      <button class="build-btn" data-type="road"><span>üõ£Ô∏è Road</span><span class="build-cost">üí∞5</span></button>
      <button class="build-btn" data-type="power"><span>‚ö° Power Line</span><span class="build-cost">üí∞10</span></button>
    </div>
    <div class="build-category">
      <div class="category-title">Residential</div>
      <button class="build-btn" data-type="habitat"><span>üè† Habitat</span><span class="build-cost">üí∞80</span></button>
      <button class="build-btn" data-type="apartment"><span>üè¢ Apartment</span><span class="build-cost">üí∞150</span></button>
    </div>
    <div class="build-category">
      <div class="category-title">Energy & Resources</div>
      <button class="build-btn" data-type="solar"><span>‚òÄÔ∏è Solar Farm</span><span class="build-cost">üí∞60</span></button>
      <button class="build-btn" data-type="reactor"><span>‚öõÔ∏è Reactor</span><span class="build-cost">üí∞200</span></button>
      <button class="build-btn" data-type="mine"><span>‚õèÔ∏è Mine</span><span class="build-cost">üí∞100</span></button>
    </div>
    <div class="build-category">
      <div class="category-title">Life Support</div>
      <button class="build-btn" data-type="farm"><span>üåæ Farm Dome</span><span class="build-cost">üí∞90</span></button>
      <button class="build-btn" data-type="water"><span>üíß Water Plant</span><span class="build-cost">üí∞70</span></button>
    </div>
    <div class="build-category">
      <div class="category-title">Advanced</div>
      <button class="build-btn" data-type="lab"><span>üî¨ Research Lab</span><span class="build-cost">üí∞180</span></button>
      <button class="build-btn" data-type="spaceport"><span>üöÄ Spaceport</span><span class="build-cost">üí∞300</span></button>
    </div>
  </div>
  
  <div id="info">
    <h4>Welcome to Mars City Builder!</h4>
    <p>Click on the grid to place buildings. Build roads to connect structures. Manage resources to grow your colony.</p>
  </div>
  
  <div id="controls">
    <div><strong>Camera Controls:</strong></div>
    <div>‚Ä¢ Left Mouse: Rotate camera</div>
    <div>‚Ä¢ Right Mouse: Pan camera</div>
    <div>‚Ä¢ Mouse Wheel: Zoom in/out</div>
    <div>‚Ä¢ WASD: Move camera</div>
    <div>‚Ä¢ Space: Reset camera</div>
    <div>‚Ä¢ Delete: Remove building</div>
    <div>‚Ä¢ Esc: Cancel selection</div>
  </div>
  
  <div id="toast"></div>
  
  <div id="menu">
    <h1>üî¥ MARS CITY 3D</h1>
    <p>Build and manage your Martian colony in full 3D. Place habitats, farms, power plants, and research facilities. Connect everything with roads and power lines. Watch your city grow from a small outpost to a thriving metropolis on the Red Planet!</p>
    <button id="startBtn">Start Building</button>
  </div>
  
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.157.0/examples/js/controls/OrbitControls.js"></script>
  <script>
(()=>{
'use strict';

// ========== BUILDING DEFINITIONS ==========
const BUILDINGS = {
  road: {
    name: 'Road',
    cost: 5,
    size: 1,
    height: 0.05,
    color: 0x2a2a2a,
    prod: {},
    desc: 'Connects buildings and allows colonists to move'
  },
  power: {
    name: 'Power Line',
    cost: 10,
    size: 1,
    height: 0.8,
    color: 0xffeb3b,
    prod: {},
    desc: 'Transmits energy across your colony'
  },
  habitat: {
    name: 'Habitat Module',
    cost: 80,
    size: 2,
    height: 2.5,
    color: 0x4fc3f7,
    prod: {pop: 8, energy: -3, food: -2, water: -2},
    desc: 'Houses colonists. Requires energy, food, and water.'
  },
  apartment: {
    name: 'Apartment Complex',
    cost: 150,
    size: 3,
    height: 4,
    color: 0x29b6f6,
    prod: {pop: 20, energy: -8, food: -5, water: -5},
    desc: 'High-density housing for growing colonies'
  },
  solar: {
    name: 'Solar Farm',
    cost: 60,
    size: 2,
    height: 1,
    color: 0x1976d2,
    prod: {energy: 15},
    desc: 'Generates clean energy from sunlight'
  },
  reactor: {
    name: 'Nuclear Reactor',
    cost: 200,
    size: 3,
    height: 3.5,
    color: 0x00e676,
    prod: {energy: 50, credits: -5},
    desc: 'Massive energy output but expensive to maintain'
  },
  mine: {
    name: 'Mining Facility',
    cost: 100,
    size: 2,
    height: 2,
    color: 0xffa726,
    prod: {credits: 8, energy: -4},
    desc: 'Extracts valuable minerals from Mars'
  },
  farm: {
    name: 'Farm Dome',
    cost: 90,
    size: 2,
    height: 2.2,
    color: 0x66bb6a,
    prod: {food: 12, energy: -3, water: -4},
    desc: 'Grows food in controlled environment'
  },
  water: {
    name: 'Water Extraction Plant',
    cost: 70,
    size: 2,
    height: 2,
    color: 0x26c6da,
    prod: {water: 10, energy: -2},
    desc: 'Extracts water from underground ice'
  },
  lab: {
    name: 'Research Laboratory',
    cost: 180,
    size: 2,
    height: 3,
    color: 0xec407a,
    prod: {research: 5, energy: -6, credits: -3},
    desc: 'Advances technology and unlocks new buildings'
  },
  spaceport: {
    name: 'Spaceport',
    cost: 300,
    size: 4,
    height: 5,
    color: 0xab47bc,
    prod: {credits: 20, energy: -10},
    desc: 'Enables trade with Earth and other colonies'
  }
};

// ========== DOM ELEMENTS ==========
const UI = {
  pop: document.getElementById('pop'),
  credits: document.getElementById('credits'),
  energy: document.getElementById('energy'),
  food: document.getElementById('food'),
  water: document.getElementById('water'),
  research: document.getElementById('research'),
  day: document.getElementById('day'),
  fps: document.getElementById('fps'),
  info: document.getElementById('info'),
  toast: document.getElementById('toast'),
  menu: document.getElementById('menu')
};

function toast(msg, duration = 1500) {
  UI.toast.textContent = msg;
  UI.toast.style.opacity = '1';
  setTimeout(() => UI.toast.style.opacity = '0', duration);
}

function updateInfo(title, desc) {
  UI.info.innerHTML = `<h4>${title}</h4><p>${desc}</p>`;
}

// ========== THREE.JS SETUP ==========
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a0f0f);
scene.fog = new THREE.Fog(0x3d1f1f, 50, 200);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
camera.position.set(30, 40, 30);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// ========== ORBIT CONTROLS ==========
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 15;
controls.maxDistance = 100;
controls.maxPolarAngle = Math.PI / 2.2;
controls.target.set(0, 0, 0);

// ========== LIGHTING ==========
const ambientLight = new THREE.AmbientLight(0xffccaa, 0.5);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffd4a3, 1.5);
sunLight.position.set(50, 80, 40);
sunLight.castShadow = true;
sunLight.shadow.camera.left = -60;
sunLight.shadow.camera.right = 60;
sunLight.shadow.camera.top = 60;
sunLight.shadow.camera.bottom = -60;
sunLight.shadow.camera.near = 0.1;
sunLight.shadow.camera.far = 200;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
scene.add(sunLight);

const fillLight = new THREE.DirectionalLight(0x6688ff, 0.3);
fillLight.position.set(-30, 20, -30);
scene.add(fillLight);

// ========== MARS TERRAIN ==========
const groundSize = 100;
const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, 50, 50);
const groundMat = new THREE.MeshStandardMaterial({
  color: 0x8b4513,
  roughness: 0.95,
  metalness: 0.05
});

// Add some terrain variation
const positions = groundGeo.attributes.position;
for (let i = 0; i < positions.count; i++) {
  const x = positions.getX(i);
  const y = positions.getY(i);
  const noise = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 0.5;
  positions.setZ(i, noise);
}
groundGeo.computeVertexNormals();

const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// ========== STARFIELD ==========
const starGeo = new THREE.BufferGeometry();
const starPositions = [];
for (let i = 0; i < 2000; i++) {
  const x = (Math.random() - 0.5) * 400;
  const y = Math.random() * 200 + 50;
  const z = (Math.random() - 0.5) * 400;
  starPositions.push(x, y, z);
}
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3 });
const stars = new THREE.Points(starGeo, starMat);
scene.add(stars);

// ========== GRID SYSTEM ==========
const GRID_SIZE = 30;
const TILE_SIZE = 3;
const tiles = [];
const tileMap = new Map();

const gridHelper = new THREE.GridHelper(GRID_SIZE * TILE_SIZE, GRID_SIZE, 0x444444, 0x222222);
gridHelper.position.y = 0.01;
scene.add(gridHelper);

// Create invisible tile meshes for raycasting
const tileGeo = new THREE.PlaneGeometry(TILE_SIZE * 0.95, TILE_SIZE * 0.95);
const tileMat = new THREE.MeshBasicMaterial({
  color: 0x5d4037,
  transparent: true,
  opacity: 0,
  side: THREE.DoubleSide
});

for (let x = -GRID_SIZE / 2; x < GRID_SIZE / 2; x++) {
  for (let z = -GRID_SIZE / 2; z < GRID_SIZE / 2; z++) {
    const tile = new THREE.Mesh(tileGeo, tileMat.clone());
    tile.rotation.x = -Math.PI / 2;
    tile.position.set(x * TILE_SIZE + TILE_SIZE / 2, 0.02, z * TILE_SIZE + TILE_SIZE / 2);
    tile.userData = { gridX: x, gridZ: z, building: null };
    scene.add(tile);
    tiles.push(tile);
    tileMap.set(`${x},${z}`, tile);
  }
}

// ========== GAME STATE ==========
const state = {
  credits: 500,
  energy: 0,
  energyCap: 0,
  food: 50,
  water: 40,
  pop: 0,
  research: 0,
  day: 1,
  time: 0,
  lastTick: 0,
  selectedType: null,
  buildings: [],
  started: false,
  paused: false,
  fpsBuf: []
};

function updateHUD() {
  UI.pop.textContent = Math.floor(state.pop);
  UI.credits.textContent = Math.floor(state.credits);
  UI.energy.textContent = `${Math.floor(state.energy)}/${Math.floor(state.energyCap)}`;
  UI.food.textContent = Math.floor(state.food);
  UI.water.textContent = Math.floor(state.water);
  UI.research.textContent = Math.floor(state.research);
  UI.day.textContent = state.day;
}

// ========== BUILDING CREATION ==========
function createBuildingMesh(type) {
  const cfg = BUILDINGS[type];
  const group = new THREE.Group();
  
  if (type === 'road') {
    const geo = new THREE.BoxGeometry(TILE_SIZE * 0.9, cfg.height, TILE_SIZE * 0.9);
    const mat = new THREE.MeshStandardMaterial({ color: cfg.color, roughness: 0.8 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.receiveShadow = true;
    group.add(mesh);
  } else if (type === 'power') {
    // Power line pole
    const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, cfg.height, 8);
    const poleMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7 });
    const pole = new THREE.Mesh(poleGeo, poleMat);
    pole.position.y = cfg.height / 2;
    pole.castShadow = true;
    group.add(pole);
    
    // Wire
    const wireGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 6);
    const wireMat = new THREE.MeshStandardMaterial({ color: cfg.color, emissive: cfg.color, emissiveIntensity: 0.5 });
    const wire = new THREE.Mesh(wireGeo, wireMat);
    wire.position.y = cfg.height;
    wire.rotation.z = Math.PI / 2;
    group.add(wire);
  } else if (type === 'habitat') {
    // Cylindrical habitat
    const bodyGeo = new THREE.CylinderGeometry(cfg.size * 0.4, cfg.size * 0.4, cfg.height, 16);
    const bodyMat = new THREE.MeshStandardMaterial({ color: cfg.color, roughness: 0.4, metalness: 0.3 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = cfg.height / 2;
    body.castShadow = true;
    body.receiveShadow = true;
    group.add(body);
    
    // Windows
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const windowGeo = new THREE.BoxGeometry(0.3, 0.4, 0.1);
      const windowMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b, emissive: 0xffeb3b, emissiveIntensity: 0.6 });
      const window = new THREE.Mesh(windowGeo, windowMat);
      window.position.x = Math.cos(angle) * (cfg.size * 0.41);
      window.position.z = Math.sin(angle) * (cfg.size * 0.41);
      window.position.y = cfg.height * 0.6;
      window.lookAt(0, window.position.y, 0);
      group.add(window);
    }
  } else if (type === 'apartment') {
    // Tall building
    const bodyGeo = new THREE.BoxGeometry(cfg.size * 0.6, cfg.height, cfg.size * 0.6);
    const bodyMat = new THREE.MeshStandardMaterial({ color: cfg.color, roughness: 0.5, metalness: 0.2 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = cfg.height / 2;
    body.castShadow = true;
    body.receiveShadow = true;
    group.add(body);
    
    // Windows grid
    for (let floor = 0; floor < 4; floor++) {
      for (let side = 0; side < 4; side++) {
        const windowGeo = new THREE.BoxGeometry(0.4, 0.5, 0.05);
        const windowMat = new THREE.MeshStandardMaterial({ color: 0x4fc3f7, emissive: 0x4fc3f7, emissiveIntensity: 0.4 });
        const window = new THREE.Mesh(windowGeo, windowMat);
        const y = (floor + 0.5) * (cfg.height / 4);
        window.position.y = y;
        
        if (side === 0) { window.position.x = cfg.size * 0.31; window.position.z = 0; }
        else if (side === 1) { window.position.x = -cfg.size * 0.31; window.position.z = 0; }
        else if (side === 2) { window.position.z = cfg.size * 0.31; window.position.x = 0; window.rotation.y = Math.PI / 2; }
        else { window.position.z = -cfg.size * 0.31; window.position.x = 0; window.rotation.y = Math.PI / 2; }
        
        group.add(window);
      }
    }
  } else if (type === 'solar') {
    // Solar panels
    const baseGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.5, 8);
    const baseMat = new THREE.MeshStandardMaterial({ color: 0x37474f, roughness: 0.7 });
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.y = 0.25;
    base.castShadow = true;
    group.add(base);
    
    for (let i = 0; i < 4; i++) {
      const panelGeo = new THREE.BoxGeometry(1.5, 0.1, 1);
      const panelMat = new THREE.MeshStandardMaterial({ color: cfg.color, roughness: 0.2, metalness: 0.8 });
      const panel = new THREE.Mesh(panelGeo, panelMat);
      panel.position.y = cfg.height;
      panel.position.x = (i % 2) * 1.6 - 0.8;
      panel.position.z = Math.floor(i / 2) * 1.2 - 0.6;
      panel.rotation.x = -Math.PI / 6;
      panel.castShadow = true;
      group.add(panel);
    }
  } else if (type === 'reactor') {
    // Nuclear reactor dome
    const domeGeo = new THREE.SphereGeometry(cfg.size * 0.5, 24, 24, 0, Math.PI * 2, 0, Math.PI / 2);
    const domeMat = new THREE.MeshStandardMaterial({ color: cfg.color, roughness: 0.3, metalness: 0.6, emissive: cfg.color, emissiveIntensity: 0.2 });
    const dome = new THREE.Mesh(domeGeo, domeMat);
    dome.position.y = cfg.height * 0.6;
    dome.castShadow = true;
    group.add(dome);
    
    const baseGeo = new THREE.CylinderGeometry(cfg.size * 0.5, cfg.size * 0.6, cfg.height * 0.6, 16);
    const baseMat = new THREE.MeshStandardMaterial({ color: 0x37474f, roughness: 0.6 });
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.y = cfg.height * 0.3;
    base.castShadow = true;
    group.add(base);
  } else if (type === 'mine') {
    // Mining facility
    const bodyGeo = new THREE.BoxGeometry(cfg.size * 0.7, cfg.height, cfg.size * 0.7);
    const bodyMat = new THREE.MeshStandardMaterial({ color: cfg.color, roughness: 0.8 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = cfg.height / 2;
    body.castShadow = true;
    group.add(body);
    
    // Drill
    const drillGeo = new THREE.ConeGeometry(0.4, 1.5, 8);
    const drillMat = new THREE.MeshStandardMaterial({ color: 0x424242, metalness: 0.8 });
    const drill = new THREE.Mesh(drillGeo, drillMat);
    drill.position.y = cfg.height + 0.5;
    drill.castShadow = true;
    group.add(drill);
  } else if (type === 'farm') {
    // Farm dome
    const domeGeo = new THREE.SphereGeometry(cfg.size * 0.5, 20, 20, 0, Math.PI * 2, 0, Math.PI / 2);
    const domeMat = new THREE.MeshStandardMaterial({ 
      color: cfg.color, 
      transparent: true, 
      opacity: 0.6, 
      roughness: 0.1,
      emissive: cfg.color,
      emissiveIntensity: 0.2
    });
    const dome = new THREE.Mesh(domeGeo, domeMat);
    dome.position.y = cfg.height * 0.5;
    dome.castShadow = true;
    group.add(dome);
    
    // Plants inside
    for (let i = 0; i < 6; i++) {
      const plantGeo = new THREE.ConeGeometry(0.2, 0.6, 6);
      const plantMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
      const plant = new THREE.Mesh(plantGeo, plantMat);
      const angle = (i / 6) * Math.PI * 2;
      plant.position.x = Math.cos(angle) * 0.8;
      plant.position.z = Math.sin(angle) * 0.8;
      plant.position.y = 0.3;
      group.add(plant);
    }
  } else if (type === 'water') {
    // Water plant
    const tankGeo = new THREE.CylinderGeometry(cfg.size * 0.4, cfg.size * 0.4, cfg.height, 16);
    const tankMat = new THREE.MeshStandardMaterial({ color: cfg.color, roughness: 0.3, metalness: 0.7 });
    const tank = new THREE.Mesh(tankGeo, tankMat);
    tank.position.y = cfg.height / 2;
    tank.castShadow = true;
    group.add(tank);
    
    // Pipes
    for (let i = 0; i < 3; i++) {
      const pipeGeo = new THREE.CylinderGeometry(0.15, 0.15, cfg.height * 0.8, 8);
      const pipeMat = new THREE.MeshStandardMaterial({ color: 0x546e7a, metalness: 0.8 });
      const pipe = new THREE.Mesh(pipeGeo, pipeMat);
      const angle = (i / 3) * Math.PI * 2;
      pipe.position.x = Math.cos(angle) * (cfg.size * 0.45);
      pipe.position.z = Math.sin(angle) * (cfg.size * 0.45);
      pipe.position.y = cfg.height * 0.4;
      group.add(pipe);
    }
  } else if (type === 'lab') {
    // Research lab
    const bodyGeo = new THREE.BoxGeometry(cfg.size * 0.7, cfg.height * 0.6, cfg.size * 0.7);
    const bodyMat = new THREE.MeshStandardMaterial({ color: cfg.color, roughness: 0.4, metalness: 0.4 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = cfg.height * 0.3;
    body.castShadow = true;
    group.add(body);
    
    // Antenna
    const antennaGeo = new THREE.CylinderGeometry(0.1, 0.1, cfg.height * 0.8, 8);
    const antennaMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.9 });
    const antenna = new THREE.Mesh(antennaGeo, antennaMat);
    antenna.position.y = cfg.height;
    antenna.castShadow = true;
    group.add(antenna);
    
    // Dish
    const dishGeo = new THREE.SphereGeometry(0.5, 16, 16, 0, Math.PI * 2, 0, Math.PI / 3);
    const dishMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, metalness: 0.8 });
    const dish = new THREE.Mesh(dishGeo, dishMat);
    dish.position.y = cfg.height * 1.3;
    dish.rotation.x = Math.PI / 4;
    group.add(dish);
  } else if (type === 'spaceport') {
    // Spaceport landing pad
    const padGeo = new THREE.CylinderGeometry(cfg.size * 0.6, cfg.size * 0.6, 0.3, 32);
    const padMat = new THREE.MeshStandardMaterial({ color: 0x37474f, roughness: 0.7, metalness: 0.5 });
    const pad = new THREE.Mesh(padGeo, padMat);
    pad.position.y = 0.15;
    pad.castShadow = true;
    group.add(pad);
    
    // Tower
    const towerGeo = new THREE.CylinderGeometry(0.8, 1, cfg.height, 8);
    const towerMat = new THREE.MeshStandardMaterial({ color: cfg.color, roughness: 0.4, metalness: 0.6 });
    const tower = new THREE.Mesh(towerGeo, towerMat);
    tower.position.y = cfg.height / 2;
    tower.position.x = cfg.size * 0.4;
    tower.castShadow = true;
    group.add(tower);
    
    // Lights
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const lightGeo = new THREE.SphereGeometry(0.2, 8, 8);
      const lightMat = new THREE.MeshStandardMaterial({ color: 0xff6432, emissive: 0xff6432, emissiveIntensity: 0.8 });
      const light = new THREE.Mesh(lightGeo, lightMat);
      light.position.x = Math.cos(angle) * (cfg.size * 0.55);
      light.position.z = Math.sin(angle) * (cfg.size * 0.55);
      light.position.y = 0.3;
      group.add(light);
    }
  }
  
  return group;
}

// ========== BUILDING PLACEMENT ==========
function canPlaceBuilding(tile, type) {
  const cfg = BUILDINGS[type];
  const gridX = tile.userData.gridX;
  const gridZ = tile.userData.gridZ;
  
  // Check if all required tiles are free
  for (let x = 0; x < cfg.size; x++) {
    for (let z = 0; z < cfg.size; z++) {
      const checkTile = tileMap.get(`${gridX + x},${gridZ + z}`);
      if (!checkTile || checkTile.userData.building) {
        return false;
      }
    }
  }
  
  return state.credits >= cfg.cost;
}

function placeBuilding(tile, type) {
  if (!canPlaceBuilding(tile, type)) {
    toast('Cannot place building here!');
    return;
  }
  
  const cfg = BUILDINGS[type];
  const gridX = tile.userData.gridX;
  const gridZ = tile.userData.gridZ;
  
  // Deduct cost
  state.credits -= cfg.cost;
  
  // Create building mesh
  const mesh = createBuildingMesh(type);
  const centerX = (gridX + cfg.size / 2 - 0.5) * TILE_SIZE + TILE_SIZE / 2;
  const centerZ = (gridZ + cfg.size / 2 - 0.5) * TILE_SIZE + TILE_SIZE / 2;
  mesh.position.set(centerX, 0, centerZ);
  scene.add(mesh);
  
  // Mark tiles as occupied
  const building = {
    type,
    mesh,
    tiles: [],
    prod: { ...cfg.prod }
  };
  
  for (let x = 0; x < cfg.size; x++) {
    for (let z = 0; z < cfg.size; z++) {
      const occupiedTile = tileMap.get(`${gridX + x},${gridZ + z}`);
      if (occupiedTile) {
        occupiedTile.userData.building = building;
        building.tiles.push(occupiedTile);
      }
    }
  }
  
  state.buildings.push(building);
  updateHUD();
  toast(`Built ${cfg.name}!`, 1000);
  updateInfo(cfg.name, cfg.desc);
}

function removeBuilding(tile) {
  const building = tile.userData.building;
  if (!building) {
    toast('No building here!');
    return;
  }
  
  // Remove mesh
  scene.remove(building.mesh);
  
  // Clear all occupied tiles
  building.tiles.forEach(t => {
    t.userData.building = null;
  });
  
  // Remove from buildings array
  const index = state.buildings.indexOf(building);
  if (index > -1) {
    state.buildings.splice(index, 1);
  }
  
  // Refund 50% of cost
  const cfg = BUILDINGS[building.type];
  state.credits += Math.floor(cfg.cost * 0.5);
  
  updateHUD();
  toast(`Removed ${cfg.name}. Refunded ${Math.floor(cfg.cost * 0.5)} credits.`, 1200);
}

// ========== RAYCASTING & INPUT ==========
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoveredTile = null;

window.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
});

window.addEventListener('click', (e) => {
  if (!state.started || e.target.tagName === 'BUTTON') return;
  
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(tiles);
  
  if (intersects.length > 0) {
    const tile = intersects[0].object;
    
    if (state.selectedType) {
      placeBuilding(tile, state.selectedType);
    } else {
      const building = tile.userData.building;
      if (building) {
        const cfg = BUILDINGS[building.type];
        updateInfo(cfg.name, cfg.desc);
      }
    }
  }
});

window.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  state.selectedType = null;
  document.querySelectorAll('.build-btn').forEach(btn => btn.classList.remove('selected'));
  toast('Selection cancelled', 800);
});

window.addEventListener('keydown', (e) => {
  if (e.code === 'Escape') {
    state.selectedType = null;
    document.querySelectorAll('.build-btn').forEach(btn => btn.classList.remove('selected'));
    toast('Selection cancelled', 800);
  }
  
  if (e.code === 'Delete') {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(tiles);
    if (intersects.length > 0) {
      removeBuilding(intersects[0].object);
    }
  }
  
  if (e.code === 'Space') {
    camera.position.set(30, 40, 30);
    controls.target.set(0, 0, 0);
  }
});

// Build menu buttons
document.querySelectorAll('.build-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const type = btn.dataset.type;
    state.selectedType = type;
    
    document.querySelectorAll('.build-btn').forEach(b => b.classList.remove('selected'));
    btn.classList.add('selected');
    
    const cfg = BUILDINGS[type];
    updateInfo(`Selected: ${cfg.name}`, cfg.desc);
    toast(`Click on the grid to place ${cfg.name}`, 1500);
  });
});

// Start button
document.getElementById('startBtn').addEventListener('click', () => {
  UI.menu.style.display = 'none';
  state.started = true;
  updateHUD();
  toast('Welcome to Mars! Start building your colony!', 2500);
});

// ========== HOVER EFFECT ==========
function updateHoverEffect() {
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(tiles);
  
  // Reset previous hover
  if (hoveredTile) {
    hoveredTile.material.opacity = 0;
  }
  
  if (intersects.length > 0 && state.selectedType) {
    const tile = intersects[0].object;
    const cfg = BUILDINGS[state.selectedType];
    
    // Highlight all tiles that would be occupied
    const canPlace = canPlaceBuilding(tile, state.selectedType);
    const color = canPlace ? 0x00ff00 : 0xff0000;
    
    for (let x = 0; x < cfg.size; x++) {
      for (let z = 0; z < cfg.size; z++) {
        const checkTile = tileMap.get(`${tile.userData.gridX + x},${tile.userData.gridZ + z}`);
        if (checkTile) {
          checkTile.material.color.setHex(color);
          checkTile.material.opacity = 0.3;
        }
      }
    }
    
    hoveredTile = tile;
  }
}

// ========== PRODUCTION & RESOURCE MANAGEMENT ==========
function calculateProduction() {
  let totalEnergy = 0;
  let totalEnergyProd = 0;
  let totalFood = 0;
  let totalWater = 0;
  let totalCredits = 0;
  let totalResearch = 0;
  let totalPop = 0;
  
  state.buildings.forEach(building => {
    const prod = building.prod;
    
    if (prod.energy) {
      if (prod.energy > 0) totalEnergyProd += prod.energy;
      else totalEnergy += prod.energy;
    }
    if (prod.food) totalFood += prod.food;
    if (prod.water) totalWater += prod.water;
    if (prod.credits) totalCredits += prod.credits;
    if (prod.research) totalResearch += prod.research;
    if (prod.pop) totalPop += prod.pop;
  });
  
  // Apply production
  state.energyCap = totalEnergyProd;
  state.energy = Math.max(0, Math.min(state.energyCap, state.energy + totalEnergy));
  state.food = Math.max(0, state.food + totalFood);
  state.water = Math.max(0, state.water + totalWater);
  state.credits += totalCredits;
  state.research += totalResearch;
  state.pop = totalPop;
  
  // Check for shortages
  if (state.energy <= 0 && totalEnergy < 0) {
    toast('‚ö†Ô∏è POWER SHORTAGE! Build more solar farms or reactors!', 2000);
  }
  if (state.food <= 0) {
    toast('‚ö†Ô∏è FOOD SHORTAGE! Build more farm domes!', 2000);
  }
  if (state.water <= 0) {
    toast('‚ö†Ô∏è WATER SHORTAGE! Build more water plants!', 2000);
  }
  
  updateHUD();
}

// ========== GAME LOOP ==========
let lastTime = performance.now();

function animate(currentTime) {
  requestAnimationFrame(animate);
  
  const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
  lastTime = currentTime;
  
  // FPS counter
  state.fpsBuf.push(1 / deltaTime);
  if (state.fpsBuf.length > 30) state.fpsBuf.shift();
  UI.fps.textContent = Math.round(state.fpsBuf.reduce((a, b) => a + b) / state.fpsBuf.length);
  
  if (!state.started) {
    renderer.render(scene, camera);
    return;
  }
  
  if (!state.paused) {
    state.time += deltaTime;
    state.lastTick += deltaTime;
    
    // Production tick every 3 seconds (1 Sol = 3 real seconds)
    if (state.lastTick >= 3) {
      state.lastTick = 0;
      state.day++;
      calculateProduction();
    }
    
    // Animate buildings
    state.buildings.forEach(building => {
      if (building.type === 'solar') {
        building.mesh.rotation.y += deltaTime * 0.1;
      }
      if (building.type === 'reactor') {
        const dome = building.mesh.children.find(c => c.geometry.type === 'SphereGeometry');
        if (dome) {
          dome.material.emissiveIntensity = 0.2 + Math.sin(state.time * 2) * 0.1;
        }
      }
      if (building.type === 'lab') {
        building.mesh.rotation.y += deltaTime * 0.2;
      }
      if (building.type === 'spaceport') {
        building.mesh.children.forEach(child => {
          if (child.material && child.material.emissive) {
            child.material.emissiveIntensity = 0.5 + Math.sin(state.time * 3 + child.position.x) * 0.3;
          }
        });
      }
    });
    
    // Rotate stars slowly
    stars.rotation.y += deltaTime * 0.01;
    
    // Update hover effect
    updateHoverEffect();
  }
  
  // Update controls
  controls.update();
  
  // Render scene
  renderer.render(scene, camera);
}

// ========== WINDOW RESIZE ==========
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ========== START GAME ==========
updateHUD();
animate(performance.now());

})();
  </script>
</body>
</html>
