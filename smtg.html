<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Red Frontier ‚Äî 3D Colony Builder</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,Segoe UI,Roboto,Arial}
  #hud{position:fixed;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;align-items:center;color:#fff;text-shadow:0 0 6px #000;z-index:10}
  #hud .group{display:flex;gap:10px;align-items:center}
  .pill{background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.18);padding:6px 10px;border-radius:999px}
  #center{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:800;font-size:28px;text-shadow:0 0 10px #000;pointer-events:none;opacity:0;transition:opacity .25s;z-index:9}
  #bar{position:fixed;left:50%;transform:translateX(-50%);bottom:10px;display:flex;gap:8px;z-index:11}
  #bar button{cursor:pointer;background:#0b2236;border:1px solid #49a9ff;color:#fff;padding:8px 12px;border-radius:10px;font-weight:700}
  #story{position:fixed;top:54px;left:10px;max-width:560px;color:#cfe8ff;background:rgba(0,20,40,.5);border:1px solid rgba(160,210,255,.25);padding:8px 10px;border-radius:10px;display:none;z-index:10}
  #menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:12}
  #menu button{cursor:pointer;background:#081a2a;color:#fff;border:1px solid #3fa9ff;padding:12px 18px;border-radius:12px;font-weight:800;box-shadow:0 0 24px rgba(63,169,255,.25),inset 0 0 12px rgba(63,169,255,.15)}
  #help{position:fixed;bottom:56px;left:50%;transform:translateX(-50%);color:#d9f0ff;font-size:13px;background:rgba(0,0,20,.55);border:1px solid rgba(160,210,255,.25);border-radius:10px;padding:6px 10px;z-index:10;text-align:center}
  #credits{position:fixed;bottom:10px;right:10px;color:#9cc8ff;font-size:12px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.15);border-radius:10px;padding:6px 8px;z-index:10}
</style>
</head>
<body>
  <div id="hud">
    <div class="group">
      <div class="pill">Lvl: <span id="lvl">1</span>/3</div>
      <div class="pill">Day: <span id="day">1</span> (<span id="tod">Dawn</span>)</div>
      <div class="pill">Events: <span id="evt">‚Äî</span></div>
      <div class="pill">FPS: <span id="fps">60</span></div>
    </div>
    <div class="group">
      <div class="pill">‚ö° <span id="energy">0</span></div>
      <div class="pill">‚õèÔ∏è <span id="ore">0</span></div>
      <div class="pill">üåæ <span id="food">0</span></div>
      <div class="pill">ü´Å <span id="oxy">0</span>%</div>
      <div class="pill">üë©‚ÄçüöÄ <span id="pop">0</span></div>
      <div class="pill">üî¨ <span id="res">0</span></div>
    </div>
  </div>

  <div id="story"></div>
  <div id="center"></div>

  <div id="help">Drag: orbit ‚Ä¢ Wheel: zoom ‚Ä¢ Right-drag: pan ‚Ä¢ Click a tile ‚Üí press 1-8 or use buttons ‚Ä¢ R rotate ‚Ä¢ Del bulldoze ‚Ä¢ P pause ‚Ä¢ L low-GPU</div>

  <div id="bar">
    <button data-b="1">1 Solar</button>
    <button data-b="2">2 Extractor</button>
    <button data-b="3">3 Habitat</button>
    <button data-b="4">4 Farm</button>
    <button data-b="5">5 O‚ÇÇ Plant</button>
    <button data-b="6">6 Battery</button>
    <button data-b="7">7 Dome</button>
    <button data-b="8">8 Lab</button>
  </div>

  <div id="menu"><button id="startBtn">Start Colony</button></div>
  <div id="credits">Textures: NASA/JPL-Caltech ‚Ä¢ SFX: Mixkit/Freesound (attr-free)</div>

  <!-- SFX -->
  <audio id="sfxBuild" preload="auto" crossorigin="anonymous" src="https://cdn.freesound.org/previews/544/544276_2290242-lq.mp3"></audio>
  <audio id="sfxError" preload="auto" crossorigin="anonymous" src="https://cdn.freesound.org/previews/331/331912_3248244-lq.mp3"></audio>
  <audio id="sfxEvent" preload="auto" crossorigin="anonymous" src="https://cdn.freesound.org/previews/178/178187_2859979-lq.mp3"></audio>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

<script>
(()=>{
// ---------- DOM ----------
const UI = {
  lvl: q('#lvl'), day: q('#day'), tod: q('#tod'), evt: q('#evt'), fps: q('#fps'),
  energy: q('#energy'), ore: q('#ore'), food: q('#food'), oxy: q('#oxy'),
  pop: q('#pop'), res: q('#res'), center: q('#center'), story: q('#story')
};
function q(s){return document.querySelector(s)}
function note(msg,ms=1200){ UI.center.textContent=msg; UI.center.style.opacity='1'; setTimeout(()=>UI.center.style.opacity='0',ms); }
function story(msg,ms=2800){ UI.story.textContent=msg; UI.story.style.display='block'; setTimeout(()=>UI.story.style.display='none',ms); }

// ---------- Renderer / Scene / Camera ----------
let lowGPU=false;
const renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 3000);
camera.position.set(14, 12, 16);
const hemi = new THREE.HemisphereLight(0x88ccff,0x201018,0.9); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff,1); dir.position.set(10,20,8); scene.add(dir);

// NASA starfield
const loader = new THREE.TextureLoader();
const skyTex = loader.load("https://www.nasa.gov/wp-content/uploads/2023/03/hs-2015-02-a-xlarge_web.jpg");
const sky = new THREE.Mesh(new THREE.SphereGeometry(1200,32,32), new THREE.MeshBasicMaterial({map:skyTex, side:THREE.BackSide, depthWrite:false}));
scene.add(sky);

// Ground ‚Äúplanetoid rim‚Äù
const ground = new THREE.Group(); scene.add(ground);
const rimGeo = new THREE.CylinderGeometry(20,20,2,64,1,true);
const rim = new THREE.Mesh(rimGeo, new THREE.MeshStandardMaterial({color:0x2b2b2b, metalness:.05, roughness:.95, side:THREE.DoubleSide}));
rim.position.y=-1.5; ground.add(rim);

const plane = new THREE.Mesh(new THREE.CircleGeometry(16, 48), new THREE.MeshStandardMaterial({color:0x3a2f2f, roughness:.95, metalness:.05}));
plane.rotation.x = -Math.PI/2; plane.position.y=-0.99; ground.add(plane);

// ---------- Camera orbit (no external controls) ----------
let isDrag=false, isRDrag=false, lastX=0,lastY=0, az=0.8, el=0.6, dist=26, panX=0,panY=0;
function updateCam(){
  const x = (dist*Math.cos(el))*Math.cos(az)+panX;
  const y = dist*Math.sin(el)+panY;
  const z = (dist*Math.cos(el))*Math.sin(az);
  camera.position.set(x,y,z);
  camera.lookAt(new THREE.Vector3(panX,0,panY));
}
addEventListener('mousedown',e=>{ if(e.button===0) isDrag=true; if(e.button===2) isRDrag=true; lastX=e.clientX; lastY=e.clientY; });
addEventListener('mousemove',e=>{
  const dx=(e.clientX-lastX), dy=(e.clientY-lastY); lastX=e.clientX; lastY=e.clientY;
  if(isDrag){ az -= dx*0.005; el = THREE.MathUtils.clamp(el - dy*0.004, -0.2, 1.2); }
  if(isRDrag){ panX -= dx*0.02; panY += dy*0.02; }
});
addEventListener('mouseup',()=>{isDrag=false; isRDrag=false;});
addEventListener('contextmenu',e=>e.preventDefault());
addEventListener('wheel',e=>{ dist = THREE.MathUtils.clamp(dist + e.deltaY*0.02, 10, 60); });
addEventListener('resize',()=>{ renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); });
updateCam();

// ---------- Grid (hex-ish) ----------
const GRID_R=8; // radius in tiles
const tiles=[];
const tileGeo = new THREE.CylinderGeometry(0.9,0.9,0.2,6);
const tileMat = new THREE.MeshStandardMaterial({color:0x553a3a, roughness:.9, metalness:.05});
const highlightMat = new THREE.MeshStandardMaterial({color:0x66ccff, roughness:.8, metalness:.2, emissive:0x113344, emissiveIntensity:.6});
let selectedTile=null;

function axialToWorld(q,r){
  const x = (Math.sqrt(3)*q + Math.sqrt(3)/2*r);
  const z = (3/2)*r;
  return new THREE.Vector3(x, 0, z);
}
for(let q=-GRID_R;q<=GRID_R;q++){
  for(let r=-GRID_R;r<=GRID_R;r++){
    if(Math.abs(q+r)>GRID_R) continue;
    const pos = axialToWorld(q,r);
    const tile = new THREE.Mesh(tileGeo, tileMat.clone());
    tile.position.set(pos.x, -0.9, pos.z);
    tile.userData={q,r, building:null, rot:0};
    plane.add(tile);
    tiles.push(tile);
  }
}

// ---------- Picking ----------
const ray = new THREE.Raycaster(); const mouse = new THREE.Vector2();
addEventListener('mousemove',e=>{
  mouse.x = (e.clientX/innerWidth)*2-1; mouse.y = -(e.clientY/innerHeight)*2+1;
});
addEventListener('click',()=>{
  ray.setFromCamera(mouse, camera);
  const ints = ray.intersectObjects(tiles,false);
  if(ints.length){
    if(selectedTile) selectedTile.material.emissiveIntensity=0;
    selectedTile = ints[0].object;
    selectedTile.material.emissiveIntensity=.6;
    note(`Tile (${selectedTile.userData.q},${selectedTile.userData.r}) selected`,800);
  }
});

// ---------- Buildings ----------
const B = {
  NONE:0, SOLAR:1, EXTRACT:2, HAB:3, FARM:4, OXY:5, BAT:6, DOME:7, LAB:8
};
const COST = {
  [B.SOLAR]: {ore:10, energy:0}, [B.EXTRACT]:{ore:20, energy:5},
  [B.HAB]:{ore:25, energy:10}, [B.FARM]:{ore:15, energy:8},
  [B.OXY]:{ore:18, energy:12}, [B.BAT]:{ore:20, energy:0},
  [B.DOME]:{ore:30, energy:5}, [B.LAB]:{ore:35, energy:15}
};
const PROD = {
  [B.SOLAR]:{energy:+6}, [B.EXTRACT]:{ore:+3, energy:-1},
  [B.HAB]:{pop:+3, oxy:-2, food:-1, energy:-1},
  [B.FARM]:{food:+3, energy:-1}, [B.OXY]:{oxy:+5, energy:-2},
  [B.BAT]:{cap:+10}, [B.DOME]:{shield:+1, energy:-1},
  [B.LAB]:{res:+2, energy:-2}
};
function makeMesh(type){
  switch(type){
    case B.SOLAR: return new THREE.Mesh(new THREE.ConeGeometry(0.8,0.3,5), new THREE.MeshStandardMaterial({color:0x3344ff, metalness:.6, roughness:.3, emissive:0x112255}));
    case B.EXTRACT: return new THREE.Mesh(new THREE.BoxGeometry(0.9,0.4,0.9), new THREE.MeshStandardMaterial({color:0x996633, metalness:.2, roughness:.9}));
    case B.HAB: return new THREE.Mesh(new THREE.SphereGeometry(0.6,16,12), new THREE.MeshStandardMaterial({color:0x88ccee, metalness:.4, roughness:.4, emissive:0x223344}));
    case B.FARM: return new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,0.35,12), new THREE.MeshStandardMaterial({color:0x77aa55, metalness:.1, roughness:.8}));
    case B.OXY: return new THREE.Mesh(new THREE.TorusKnotGeometry(0.35,0.12,60,10), new THREE.MeshStandardMaterial({color:0x66ffee, metalness:.6, roughness:.2, emissive:0x114433}));
    case B.BAT: return new THREE.Mesh(new THREE.CapsuleGeometry(0.35,0.5,4,10), new THREE.MeshStandardMaterial({color:0xffd15a, metalness:.6, roughness:.3}));
    case B.DOME: return new THREE.Mesh(new THREE.SphereGeometry(0.75,18,14,0,Math.PI*2,0,Math.PI/2), new THREE.MeshStandardMaterial({color:0x55aaff, metalness:.2, roughness:.1, transparent:true, opacity:.35}));
    case B.LAB: return new THREE.Mesh(new THREE.TorusGeometry(0.65,0.13,12,20), new THREE.MeshStandardMaterial({color:0xff6699, metalness:.7, roughness:.25, emissive:0x441122}));
  }
}
function canAfford(type){
  const c=COST[type]||{};
  return state.ore >= (c.ore||0) && state.energyStored >= (c.energy||0);
}
function pay(type){
  const c=COST[type]||{};
  state.ore -= (c.ore||0);
  state.energyStored -= (c.energy||0);
  hud();
}
function build(type){
  if(!selectedTile){ ding('Select a tile first'); return; }
  if(selectedTile.userData.building){ ding('Bulldoze first (Del)'); return; }
  if(!canAfford(type)){ ding('Not enough resources'); return; }
  const m = makeMesh(type); m.position.y = -0.6; selectedTile.add(m);
  selectedTile.userData.building = {type, mesh:m};
  pay(type);
  chime();
}
function rotateSel(){
  if(!selectedTile||!selectedTile.userData.building) return;
  selectedTile.userData.rot += Math.PI/6;
  selectedTile.userData.building.mesh.rotation.y = selectedTile.userData.rot;
}
function bulldoze(){
  if(!selectedTile||!selectedTile.userData.building) return;
  selectedTile.remove(selectedTile.userData.building.mesh);
  selectedTile.userData.building=null;
  note('Bulldozed',600);
}

// ---------- Resources / Day cycle / Events ----------
const state = {
  lvl:1, day:1, tod:0, // 0..1
  energyStored: 10, energyCap: 20, ore: 20, food: 8, oxy: 60, pop: 4, res: 0,
  shieldLevel:0,
  paused:false, started:false,
  time:0, lastTick:0, fpsBuf:[]
};
function hud(){
  UI.lvl.textContent = state.lvl; UI.day.textContent = state.day;
  UI.energy.textContent = Math.floor(state.energyStored)+'/'+state.energyCap;
  UI.ore.textContent = Math.floor(state.ore);
  UI.food.textContent = Math.floor(state.food);
  UI.oxy.textContent = Math.floor(state.oxy);
  UI.pop.textContent = Math.floor(state.pop);
  UI.res.textContent = Math.floor(state.res);
}
function todLabel(x){ return x<0.2?'Dawn':x<0.5?'Day':x<0.8?'Dusk':'Night'; }

function envMultipliers(){
  const isDay = state.tod>0.2 && state.tod<0.8;
  const light = isDay ? 1 : 0.25;
  const storm = currentEvent==='Storm' ? 0.5 : 1;
  return {light, storm};
}

let currentEvent='‚Äî', eventTimer=0;
function randomEvent(){
  // Level 1: rare storms; Level 2: storms common; Level 3: meteors appear
  const r=Math.random();
  if(state.lvl===1 && r<0.08) startStorm();
  else if(state.lvl===2 && r<0.16) (r<0.13?startStorm():startQuake());
  else if(state.lvl===3 && r<0.22) (r<0.16?startStorm():startMeteor());
}
function startStorm(){ currentEvent='Storm'; eventTimer=12; sfx('sfxEvent'); UI.evt.textContent='Dust Storm'; story('Dust storm reduces solar and farm output. Domes protect adjacent tiles.'); }
function startQuake(){ currentEvent='Quake'; eventTimer=6; sfx('sfxEvent'); UI.evt.textContent='Seismic Tremor'; story('Minor tremor disrupts extractors briefly.'); }
function startMeteor(){ currentEvent='Meteor'; eventTimer=1.5; sfx('sfxEvent'); UI.evt.textContent='Meteor Strike!'; story('Incoming meteor‚Äîdomes negate damage in a small radius.'); meteorStrike(); }

function endEvent(){ currentEvent='‚Äî'; UI.evt.textContent='‚Äî'; }

function sfx(id){ try{ const a=document.getElementById(id); a.currentTime=0; a.play(); }catch{} }
function chime(){ sfx('sfxBuild'); }
function ding(msg){ sfx('sfxError'); note(msg,900); }

// Meteor effect: remove one random unprotected building
function meteorStrike(){
  const candidates = tiles.filter(t=>t.userData.building);
  if(!candidates.length) return;
  const t = candidates[Math.floor(Math.random()*candidates.length)];
  // Check for nearby dome
  const hasDome = tiles.some(o=>{
    if(!o.userData.building || o.userData.building.type!==B.DOME) return false;
    const d = o.position.distanceTo(t.position);
    return d < 3.2;
  });
  if(hasDome){ note('Meteor intercepted by dome!',1000); return; }
  t.remove(t.userData.building.mesh); t.userData.building=null;
  note('Meteor destroyed a building!',1200);
}

// Production tick every ~1s (scaled by time)
function tick(dt){
  // Time of day
  state.tod += dt*0.02; if(state.tod>1){ state.tod-=1; state.day++; if(state.day%2===0) randomEvent(); }
  UI.tod.textContent = todLabel(state.tod);

  // Natural decay/consumption
  const consumeEnergy = 0.2 + state.pop*0.02;
  const consumeFood   = state.pop*0.01;
  const consumeOxy    = state.pop*0.05;

  // Base production from buildings
  let dE=0,dO=0,dF=0,dOre=0,dCap=0,dShield=0,dRes=0,dPop=0;
  const mult = envMultipliers();

  tiles.forEach(t=>{
    const b = t.userData.building?.type;
    if(!b) return;
    switch(b){
      case B.SOLAR: dE += (PROD[b].energy||0) * mult.light * (currentEvent==='Storm'?0.4:1); break;
      case B.EXTRACT: dOre += (currentEvent==='Quake'?1:PROD[b].ore||0); dE += (PROD[b].energy||0); break;
      case B.FARM: dF += (PROD[b].food||0) * (currentEvent==='Storm'?0.6:1); dE += (PROD[b].energy||0); break;
      case B.OXY: dO += (PROD[b].oxy||0); dE += (PROD[b].energy||0); break;
      case B.HAB: dPop += (PROD[b].pop||0); dO += (PROD[b].oxy||0||0); dF += (PROD[b].food||0||0); dE += (PROD[b].energy||0); break;
      case B.BAT: dCap += (PROD[b].cap||0); break;
      case B.DOME: dShield += (PROD[b].shield||0); dE += (PROD[b].energy||0); break;
      case B.LAB: dRes += (PROD[b].res||0); dE += (PROD[b].energy||0); break;
    }
  });

  // Apply caps & stores
  state.energyCap = 20 + dCap;
  state.energyStored = THREE.MathUtils.clamp(state.energyStored + dE - consumeEnergy, 0, state.energyCap);
  state.ore   += dOre;
  state.food  = Math.max(0, state.food + dF - consumeFood);
  state.oxy   = THREE.MathUtils.clamp(state.oxy + dO - consumeOxy, 0, 120);
  state.res   += dRes;
  state.shieldLevel = dShield;
  state.pop   = Math.max(0, Math.floor(4 + dPop*0.2)); // simplified pop growth from habs

  // Simple fail states
  if(state.energyStored<=0 && state.tod>0.2 && state.tod<0.8){ /* day helps but if zero for long, risky */ }
  if(state.oxy<=5){ note('Oxygen critical!',900); }
  if(state.oxy<=0){ gameOver('Colony suffocated'); }

  // Level goals
  if(state.lvl===1 && state.ore>=80 && state.energyStored>=40){ state.lvl=2; story('Phase 2: Habitat expansion unlocked. Survive storms. New threat: tremors.'); }
  if(state.lvl===2 && state.pop>=14 && state.food>=30 && state.oxy>=80){ state.lvl=3; story('Phase 3: Research priority. Meteors possible‚Äîbuild domes to protect.'); }
  if(state.lvl===3 && state.res>=80 && state.pop>=18){ win(); }

  // Event timer
  if(currentEvent!=='‚Äî'){ eventTimer -= dt; if(eventTimer<=0) endEvent(); }

  hud();
}

// ---------- UI bindings ----------
document.getElementById('startBtn').addEventListener('click',()=>{
  q('#menu').style.display='none';
  state.started=true; state.paused=false;
  hud();
  story('Mission: Establish a self-sustaining outpost, expand habitats, then push research to stabilize the rift network. Domes protect from meteors; batteries raise energy cap.');
});

qAll('#bar button').forEach(b=>{
  b.addEventListener('click',()=>build(parseInt(b.dataset.b,10)));
});
function qAll(s){return Array.from(document.querySelectorAll(s))}
addEventListener('keydown',e=>{
  if(e.key>='1'&&e.key<='8') build(parseInt(e.key,10));
  if(e.code==='Delete') bulldoze();
  if(e.code==='KeyR') rotateSel();
  if(e.code==='KeyP'){ state.paused=!state.paused; note(state.paused?'Paused':'Resume'); }
  if(e.code==='KeyL'){ lowGPU=!lowGPU; renderer.setPixelRatio(lowGPU?1:Math.min(devicePixelRatio,2)); note(lowGPU?'Low-GPU Mode':'Quality Mode'); }
});

// ---------- Loop ----------
let last=performance.now();
function loop(now){
  requestAnimationFrame(loop);
  const dtRaw=Math.min(0.05,(now-last)/1000); last=now;
  // fps
  state.fpsBuf.push(1/dtRaw); if(state.fpsBuf.length>10) state.fpsBuf.shift();
  UI.fps.textContent = Math.round(state.fpsBuf.reduce((a,b)=>a+b,0)/state.fpsBuf.length);

  if(!state.started){ renderer.render(scene,camera); return; }
  if(!state.paused){
    state.time += dtRaw;
    // subtle sky
    sky.rotation.y += 0.0004;
    // tick about each second
    state.lastTick += dtRaw;
    if(state.lastTick>1){ tick(state.lastTick); state.lastTick=0; }

    // animate domes shimmer at night
    const isNight = !(state.tod>0.2 && state.tod<0.8);
    tiles.forEach(t=>{
      const b=t.userData.building?.type;
      if(b===B.DOME){
        t.userData.building.mesh.material.opacity = isNight?0.45:0.35;
      }
    })
  }

  updateCam();
  renderer.render(scene,camera);
}
requestAnimationFrame(loop);

// ---------- End states ----------
function gameOver(msg){
  state.paused=true;
  note('Game Over ‚Äî '+msg,2600);
}
function win(){
  state.paused=true;
  note('Colony stable ‚Äî You win!',2400);
}

})();
</script>
</body>
</html>